package interview.leetcode;

import java.util.ArrayList;
import java.util.List;

/**
 * The set [1,2,3,…,n] contains a total of n! unique permutations.
 * 
 * By listing and labeling all of the permutations in order, We get the
 * following sequence (ie, for n = 3):
 * 
 * "123" "132" "213" "231" "312" "321"
 * 
 * This sequence is not generated by swap as you can see 312 is ahead of 321 (
 * if it is by swapping, 321 should be ahead of 312).
 * 
 * It is generated in a way more like generate one digit by digit by order: 1XX,
 * 2XX, 3XX, in 1XX, you can have 12X, 13X, etc....
 * 
 * Given n and k, return the kth permutation sequence.
 * 
 * Note: Given n will be between 1 and 9 inclusive.
 * 
 * @author yazhoucao
 * 
 */
public class Permutaion_Sequence {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Permutaion_Sequence o = new Permutaion_Sequence();
		System.out.println(o.getPermutation(2, 1));
	}

	/**
	 * Directly calculate the kth permutation by calculating its every digit.
	 * 
	 * 这道题目算法上没有什么特别的，更像是一道找规律的数学题目。我们知道，n个数的permutation总共有n阶乘个，
	 * 基于这个性质我们可以得到某一位对应的数字是哪一个。
	 * 思路是这样的，比如当前长度是n，我们知道每个相同的起始元素对应(n-1)!个permutation，也就是(n-1)!
	 * 个permutation后会换一个起始元素。
	 * 因此，只要当前的k进行(n-1)!取余，得到的数字就是当前剩余数组的index，如此就可以得到对应的元素。
	 * 如此递推直到数组中没有元素结束。实现中我们要维护一个数组来记录当前的元素，每次得到一个元素加入结果数组，
	 * 然后从剩余数组中移除，因此空间复杂度是O(n)。时间上总共需要n个回合，而每次删除元素如果是用数组需要O(n),
	 * 所以总共是O(n^2)。这里如果不移除元素也需要对元素做标记，所以要判断第一个还是个线性的操作。
	 */
	public String getPermutation(int n, int k) {
		StringBuilder sb = new StringBuilder();
		List<String> nums = new ArrayList<String>();
		int total = 1;
		for (int i = 1; i <= n; i++) {
			total = total * i; // init total to n!
			nums.add(Integer.toString(i));
		}
		k--;
		for (int i = n; i > 0; i--) { // reason each digit
			total /= i; // (n-1)!
			int idx = k / total; //
			sb.append(nums.get(idx));
			nums.remove(idx);
			k = k % total;
		}
		return sb.toString();
	}

	/**
	 * Second time
	 * 1 2 3 4 .... n
	 * 
	 * 1. calculate what the current number should be, number = k / (n-1)!
	 * 1.a. update k = k % (n-1)! , update fac = fac / n -1
	 * 2. remove it from the original list
	 * 3. repeat step 1 until the list is empty
	 * 
	 */
	public String getPermutation2(int n, int k) {
		StringBuilder sb = new StringBuilder();
		List<String> numbs = new ArrayList<>();
		int fac = 1;
		for (int i = 1; i <= n; i++) {
			numbs.add(String.valueOf(i));
			fac *= i;
		}
		k--;
		for (int i = n; i >= 1; i--) {
			fac /= i;
			int idx = k / fac;
			sb.append(numbs.get(idx));
			k %= fac;
			numbs.remove(idx);
		}
		return sb.toString();
	}
}
